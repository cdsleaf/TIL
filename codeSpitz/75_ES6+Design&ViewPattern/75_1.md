# Code Spitz 75 - 1 Day 

[Code Spitz 75](https://www.facebook.com/groups/codespitz/) 강의 내용을 정리한 글 입니다.

## Warming up ES2015+ & HTML5

Warming up code.  
```HTML5
<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>CodeSpitz75-1</title>
    </head>
    <body>
        <section id="data"></section>
    </body>
    <script>
        const Table =(_=>{ 

            /* 
            본 공간에 정의한 변수는  free variable(자유변수)가 되어 외부에서 직접 접근이 불가능 함.
            class만 알아야하는 private한 것 들을 두기 위해 Closure 공간을 만드는 것.
            <static private>
            */
            const Private = Symbol();
            return class{
                constructor(parent){
                    //parent에 대한 주석없이 shield pattern으로 처리
                    if(typeof parent != 'string' || !parent) throw "invalid param";
                    this[Private] = {parent};
                }
                async load(url){
                    const response = await fetch(url);
                    const json = response.json;
                    const {title, header, items} = json; //객체 해제구문에서는 해당 key 값이 없는 경우엔 undefinend 처리 하지만, 형식 자체가 안맞는 경우 throw 처리함.-> 1차 방어
                    if(!items.length) throw "no items";
                    Object.assign(this[Private], {title, header, itmes});
                    this._render();
                }
                _render(){
                    //의사코드
                    //부모, 데이터 체크
                    const fields = this[Private], parent = document.querySelector(fields.parent);
                    if(!parent) throw "invaild parent";
                    if(!fields.items || !fields.items.length){ //데이터 검증이 아닌, 데이터가 정상이라는 전제하에 경우의 수를 분기하는 부분 임. 
                        parent.innerHTML = "no data";
                        returnl
                    } else parent.innerHTML = "";
                    //table생성
                    const table = document.createElement("table");  
                    //캡션을 title
                    const caption = document.createElement("caption");
                    caption.innerHTML = fields.title;
                    table.appendChild(caption);
                    //header를 thead로
                    table.appendChild(
                        fields.header.reduce((thead, data) => {
                            const th = document.createElement("th");
                            th.innerHTML = data;
                            thead.appendChild(th);
                            return thead;
                        }, document.createElement("thead"))
                    );
                    //itmes를 tr로
                    //부모에 table 삽입
                    parent.appendChild(
                        fields.items.reduce((table, row) => {
                            table.appendChild(
                                row.reduce((tr, col) => {
                                    const td = document.createElement("td");
                                    td.innerHTML = col;
                                    tr.appendChild(td);
                                    return tr;
                                }, document.createElement("tr"))
                            );
                            return table;
                        }, table)
                    );
                }
            };
        })();

        cosnt table = new Table("#data");
        table.load("https://raw.githubusercontent.com/cdsleaf/TIL/master/codeSpitz/75_ES6%2BDesign%26ViewPattern/75_1.json");
    </script>
</html>
```

### 용어 정리

1. Symbol : 고유하고 수정 불가능한 데이터 타입. Symbol Object는 Primitive data type

2. fetch : https://developer.mozilla.org/ko/docs/Web/API/Fetch_API

3. free variable : 클로저만 접근 할 수 있는 클로저 외부함수의 인자 또는 지역변수. 외부에서 직접 접근이 불가능하며 클로저만 접근 할 수 있어 일종의 private 변수처럼 사용 가능

4. Object.assign : Object를 복사. 다만, 프로퍼티의 참조를 복사 하기에 깊은 복제 시 주의 필요 (프로퍼티가 객체라면 object의 복제본의 값을 변경하면 참조에 따라 원본도 변경 됨.)

### 기억 할 내용

1. 프로그래밍의 작성 순서  
프로그램의 목적을 기반으로 시나리오를 만들고 해당 시나리오를 잘 표현하는 추상화된 코드를 먼저 짠다. 
(여기에서는 json을 받아서 table 형태로 화면에 출력한다.)
이후, 해당 시나리오에 따라 작성한 코드에서 필요한 부분을 만들던지, 외부 라이브러리를 쓰던지.
무턱대고 table class 부터 먼저 만드는 게 아니다. table class는 만들 수도 있지만, 외부 라이브러리에서 가져다 쓸 가능성 도 있다.

2. 주석은 무엇도 보장하지 않는다. 주석을 남길 필요가 없도록 모든 내용은 코드로 표현하라.   
 코드는 수정되도 주석은 잘 수정하지 않기 때문.

3. 외부에 공개하기 싫은 경우, 노출하지 않는 방법을 최대한 강구하라.
    - 자바스크립트에서는 변수나 함수의 이름 앞에 '_' 를 추가 한다.
    - Symbol 을 활용한다. ex) const Private = Symbol(); 
    - weakMap을 활용한다. <TODO> 예시 보강 필요.
    - '_' 나 Symbol 로 만들어도 외부에서 접근은 가능하다. 다만, 이렇게 까지해서 가져다 쓰는 개발자와는 같이 일하지 말자... (Symbol은 hasOwnProperty로 접근 가능)

4. 입력 받는 인자에 대한 검증로직을 충분히 만들어라.  
인자를 믿지 말고 항상 의심하라. 검증로직에선 throw를 만들고 에러 메시지를 작성하자.  

5. this를 활용하라.  
내부에서는 인자로 서로 주고 받지 말고 this를 활용하라. this는 이미 한번 검증을 거친 white list 이기 때문에, 내부에서는 인자 없이 this만 사용한다.  
this가 아닌 인자로 주고 받을 시, 인자를 받는 부분에서 검증로직이 들어가야 하므로 불필요한 코드가 늘어날 수 밖에 없다.  

6. 의사코드를 작성하라.
프로그램의 목적과 흐름을 의사코드로 작성하라. 자기자신에게 가장 익숙한 언어로 의사코드를 작성하고 의사코드를 프로그래밍 언어 코드로 변환하는 연습을 하자.  
프로그램 명세서 -> 의사코드 -> 프로그래밍 언어 코드  ex) _render 함수 부분을 보자.

7. Error 의 3단계
    - Compile Error : javascript에서는 유일하게 Syntax Error 만 발생
    - Runtime Error : NullPointer 등... 특정 조건에서 발생하며 throw 처리 하지 않으면 다른 부분으로 전파되어 추적이 매우 어려움. 에러가 발생 할 수 있는 부분에서 무조건 빨리 throw 던져서 멈추도록 해야 함. 
    - Context Error : 프로그램이 죽지 않고 의도와 다르게 동작함. 프로그램 수정 뿐만 아니라 이미 변경된 데이터까지 수정해야 하므로 치명적.

## Introduce

모든 프로그램은 변한다. 복잡하고 어려운 프로그램을 어떻게 변경할 수 있을 것인가?  

**격리(Isolation)** : 한쪽에 변화가 생겨도 다른 쪽에 영향을 주는 않는 것.

소프트웨어 공학의 상당부분은 **격리 전략**  

격리 전략의 기본 : 변화율에 따라 작성하기 (수정 요청이 오는 빈도) 

변화율에 따라서 부분부분으로 적절히 쪼개 놓자.  
하나의 수정건에 따라 영향이 많다면 격리 전략이 없이 개발한 것.

변화율이란 시간적인 대칭성   
변화의 원인과 주기별로 정리 : 실천수직 **"강한응집성" & "약한 의존성"**

강한 응집을 위해 table이 load 기능을 가지고 있으면 안된다. -> 역할 모델 고려.  
table이 data loading에 대한 책임을 져야 할까? 이상하지 않은 가?



> Practice #1
>
> Q. 실제코드를 구현하고 실행하면 예외가 발생한다. 예외의 지점을 찾고 수정하여 완성하라.

> Practice #2
>
> Q. 지금까지 전개한 객체협력모델에서는 여전히 문제가 남아있다. Info는Data와Renderer 사이에 교환을 위한 프로토콜인데 Renderer의 자식인TableRenderer도 Info에 의존적인 상태다. 이를 개선하라.