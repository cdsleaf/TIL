# Code Spitz 75 - 2 Day

[Code Spitz 75](https://www.facebook.com/groups/codespitz/) 강의 내용을 정리한 글 입니다.

## Design Pattern Category

GOF의 디자인패턴 분류    
 - 생성패턴 : 객체를 만드는 건 이런 식이 좋다 라는 패턴  
 - 구조패턴 : 객체간의 관계를 만들때 이런 식이 좋다 라는 패턴  
 - 행동패턴 : 알고리즘적인 문제를 객체간의 협력망으로 풀자.  

이건 객체지향에 숙달한 사람을 지향한다.  

객체지향설계를 학습할 수 있는 분류  
 - 다형성, 캡슐화, 객체관계, 변화율, 역할모델 => 이중에 역할모델이 가장 중요.  

알고리즘이 변화하는 이유는? 
 - 비즈니스변화, 연관 라이브러리 변화, 호스트측 변화 => 대부분 통제불가요소 => 변화를 수용할 수 밖에 없다.  

기존 제어문 기반의 알고리즘이 갖는 문제 : 수정하면 전체가 컴파일 됨.    

전체가 컴파일 되는 문제를 해결하기 위해 환경이 변화거나 수정요청이 발생 했을 때,  
유연하게 대응하는 실천 방법 => **적응형 프로그램**   
그리고 실천방법중 하나가 **객체지향프로그래밍**    

## 상속 위임 & 소유 위임

아래와 같이 다양한 케이스가 존재하는 코드가 있다고 해보자.
```javascript
if(case == 1){
    //....
}else if(case == 2){
    //....
}else if(case == 3){
    //....
}
```
위와 같은 코드의 경우 아래 코드 처럼 최대한 개별 알고리즘을 함수로 분리한다.
```javascript
if(case == 1){
    case1();
}else if(case == 2){
    case2();
}else if(case == 3){
    case3();
}
```
문제 1. 경우가 늘어나거나 변경될 때: 이런 경우는 경우가 전체 소스코드를 컴파일해야 함.  
```javascript
if(case == 1){
    case1();
}else if(case == 2){
    case2();
}else if(case == 4){
    case4();
}
```
문제 2. 함수 간 공통부분 : 역시나 전체 소스코드를 컴파일..  
```javascript
if(case == 1){
    common();
    case1();
}else if(case == 2){
    common();
    case2();
}else if(case == 4){
    case4();
}
```

알고리즘 분화(if.. case...) 시 객체지향에서 선택할 수 있는 두가지 방법
1. 상속 위임 - 내부계약관계로 추상층에서 공통요소를 해결하고 상태를 공유할 수 있음. 첫날 사용해던 방법.

2. 소유 위임 - 외부계약 관계로 각각이 독립적인 문제를 해결하며 메세지를 주고 받는 것으로 문제를 해결함. Gof DP 방향성.주로 소유위임을 바탕으로 함 - 문제점:형이 많이 나온다.
첫날 코드에서 renderer, data 서로 상속관계도 아니고 소유도 아님. 상속,소유위임 보다 더 나아간 주제를 구현한 코드 임. => 둘 사이는 프로토콜을 통해 분리(완전한 격리)

개발실력이 뛰어나도 도메인에 대해 잘 모른다면, 변화에 따른 역할분리 제대로 못함.  

## 상속 위임 - Github Code

상속 위임 샘플코드
```javascript
const Github = class{ //정의시점 - 변하지 않는 부분
    constructor(id, repo){
        this._base = `https://api.github.com/repos/${id}/${repo}/contents/`;
    } 
    load(path){ //공통부분 - Template Method
        const id = 'callback' + Github._id++;
        const f = Github[id] = ({data:{content}})=>{ //data, content 는 github 보내주는 json 
            delete Github[id];
            document.head.removeChild(s);
            this._loaded(content); //위임 부분
        };
        const s = document.createElement('script');
        s.src = `${this._base + path}?callback=Github.${id}`; //jsonp - 관련 내용은 마지막에..
        documnet.head.appenChild(s);
    }
    _loaded(v){thorw 'override!';} //Hook
};
Github._id = 0;
const ImageLoader = class extends Github{//실행시점선택지 - 변하는 부분
    _loaded(v){...}
}
```
상속위임 : Template Method Pattern  
위에서 load 는 Template 이라고 부르고 _loaded 는 hook 이라고 부른다.

위 내용을 아래와 같이 설명이 가능하다.  
> Github class를 Template Method Pattern 으로 구현할테니, _loaded 를 Hook 으로 만들어 주세요.   

이것이 바로 디자인패턴의 힘 - 용어를 통일함으로써 어려운 내용을 보다 쉽게 의사소통 할 수 있다.

Template Method 를 가지는 Github class는 변하는 않는 부분이라 볼 수 있다.   
즉, 내부의 코드는 변화가 적을 것이라 예상하는 부분.  
위임구현을 하는 부분인 ImageLoader 는 변화가 많을 것이라 예상하는 부분.  

## 상속 위임 - ImageLoader Code

```javascript
const ImageLoader = class extends Github{
    constructor(id, repo, target){
        super(id, repo);
        this._target = target;
    }
    _loaded(v){
        this._target.src = 'data:text/plain;base64,' + v; //base64 형식만 기술하면 이미지 src가 됨.
    }
};

const s75img = new ImageLoader(
    'hikaMaeng',
    'codespitz75',
    document.querySelector('#a')
);
s75img.load('einBig.png');
```
ImageLoader는 hook 만 구현하면 됨.(_loaded)  
ImageLoader 와 같은 경우 구상, 구현 클래스 라고 번역하는데 그것보다 concrete class 라고 기억하자.  

위에서 배운 디자인패턴 용어를 활용해서 앞으로 할일을 표현해보자.

> ImageLoader는 Github에 구현되어있는 _loaded 를 구현 해주세요.

data url : html5 스펙상 위 코드의 이미지 데이터(v) 앞에 data:text/plain 및 base64 임을 알려주면 그림이 바로 보이게 됨.  

ImageLoader 클래스는 상속을 통해서 _loaded 를 위임 받아 이미지를 보여주는 역할을 수행한다.  

## 상속 위임 - MdLoader Code

```javascript
const MdLoader = class extends Github{
    constructor(id, repo, target){
        super(id, repo);
        this._target = target;
    }
    _loaded(v){
        this._target.innerHTML = this._parseMD(V);
    }
    _parseMD(v){
        return d64(v).split('\n').map(v=>{
            let i=3;
            while(i--){
                if(v.startsWith('#'.repeat(i+1))) return `<h${i+1}>${v.substr(i+1)}</h${i+1}>`;
            }
            return v;
        }).join('<br>');
    }
};
const d64=v=>decodeURIComponent(
    atob(v).split('').map(c=>'%' + ('00' +c.charCodeAt(0).toString(16)).slice(-2)).join('');
);

const s75md = new MdLoader('hikaMaeng', 'codespitz75', document.querySelector('#b'));s
s75md.load('README.md');
```

atob : 브라우저에 내장된 함수. base64 encoding/decoding 가능. 이런거 짜지 말고 검색해서 가져다 쓰자. 시간 없다.  

## 상속 위임에서 정의시점과 실행시점

```
//정의 시점 시작
<script src="Github.js"></script>
<script src="ImageLoader.js"></script>
<script src="MdLoader.js"></script>
//정의 시점 끝
//실행시점 선택 시작
<script>
const img = new ImageLoader(...);
img.load(...);

const md = new MdLoader(...);
md.load(...);
</script>
//실행시점 선택 끝
```
정의시점은 분기가 없고, 실행시점에서 처리 함으로 써, 변화가 생겨도(조건이 변하거나 분기가 늘어나거나) 실행시점만 수정이 발생하므로, 정의시점에 대한 격리가 가능해진다.  

클래스의 자식클래스를 만듬으로 써 경우의 수를 분기했다.

## 소유 위임 - Github Code

```javascript
const Github = class{ //정의시점 - 변하지 않는 부분
    constructor(id, repo){
        this._base = `https://api.github.com/repos/${id}/${repo}/contents/`;
    } 
    load(path){
        if(!this._parser) return; //소유 위임에서 추가 부분
        const id = 'callback' + Github._id++;
        const f = Github[id] = ({data:{content}})=>{ 
            delete Github[id];
            document.head.removeChild(s);
            //this._loaded(content); //상속 위임에서 위임 부분
            this._parser(content) //소유 위임에서 위임부분
        };
        const s = document.createElement('script');
        s.src = `${this._base + path}?callback=Github.${id}`; 
        documnet.head.appenChild(s);
    }
    //_loaded(v){thorw 'override!';} //상속 위임에서 Hook 부분
    set parser(v){this._parser = v;} //소유 위임에서 위임객체 (Strategy object)  // 실행시점 선택지  - 변하는 부분
};
Github._id = 0;
```

소유위임 : Strategy Pattern

상속 위임에서는 set parser의 인자인 v를 통해 _parser를 정의하고 있다.   
Github의 set parser에서 ImageLoader 또는 MdLoader를 받아들이냐에 따라 손쉽게 로직이 교체된다.
여기엔 함수 또는 객체가 온다. 이를 전략객체, 전략함수 라고 부른다.

상속 위임 모델에 비해 클래스 정의를 덜해도 된다. 필요한 부분만 전략함수로 넘겨주면 되니까.(물론 전략객체는 제외)
대신 전략함수의 안전성을 우리가 담보해야 한다. 객체는 타입으로 판별이 가능해서 안전이 담보되기 때문.
전략함수를 쓰면 타입의 강점을 잃어버린다. 대신 형을 많이 정의하지 않아도 되는 장점이 있다. 

만약 위임하는 부분이 원자로 연료 교체 !! 같은 매우 중요한 일이면 함수보다 객체를 받는게 낫다.(형 체크 가능하니까.)

위험하면 위험할 수록 강타입을 쓰는 거고 아니면 편하게 함수를 보내면 된다.  

## 소유 위임 Concreate Loader

```javascript
const el =v=>document.querySelector(v);
const parseMD =v=>...;
const loader = new Github('hikaMaeng', 'codespitz75');

//img
const img =v=>el('#a').src = 'data:text/plain;base64';
loader.parser = img;
loader.load('xx.png');

//md
const md =v=>el('#b').innerHTML = parseMD(v);
loader.parser = md;
loader.load('xx.md');
```
위 코드에서 처럼 parsr에 변화하는 전략객체/함수만 바꿔넣으면 다른 로직으로 손쉽게 사용 가능.  

게임 상의 캐릭터를 보면, 칼, 활, 도끼 등 공격용 무기를 전략객체로 받아서 어택을 위임한 것. 소유 위임 모델이 좋음.    
NPC, 유저PC 등등 보면 개별 객체이므로 상속 위임 모델을 하는게 더 유리  

상속 / 소유 모두 이미지나 md 의 로직이 변경되어도 Github 클래스는 건드리지 않아도 된다. 변화율에 따라 분리 한 것.    

## 자유변수를 통한 확장

소유 위임 Concreate Loader 코드에서 img , md의 함수는 각각 #a, #b 로 고정되어 있음. 좀 더 유연하게 처리 할 수 있도록 코드를 바꿔보자. -> 추가적인 상태를 더 받을 수 있도록.  

```javascript
const Github = class{ 
    constructor(id, repo){
        this._base = `https://api.github.com/repos/${id}/${repo}/contents/`;
    } 
    load(path){
        if(!this._parser) return; 
        const id = 'callback' + Github._id++;
        const f = Github[id] = ({data:{content}})=>{ 
            delete Github[id];
            document.head.removeChild(s);
            this._parser[0](content, ...this._parser[1]); //인자배열 처리 할 수 있도록 변경 됨.  
        };
        const s = document.createElement('script');
        s.src = `${this._base + path}?callback=Github.${id}`; 
        documnet.head.appenChild(s);
    }
    setParser(f, ...arg){this._parser = [f, arg];} //함수외에 넘겨줄 인자배열이 추가 됨.
};
Github._id = 0;
```
전략함수를 쓸 때 문제점 -> 외부 상태를 기억하지 않는다. 그래서 인자배열을 추가 한 것.
아래코드에서는 setParser 에서 인자배열을 추가로 받음에 따라 #a #b의 종속에서 벗어난 유연한 코드로 변경 됨.  

```javascript
const el =v=>document.querySelector(v);
const parseMD =v=>...;
const loader = new Github('hikaMaeng', 'codespitz75');

//img
const img =(v, el)=>el.src = 'data:text/plain;base64';
loader.setParser = (img, el('#a')); //상태가 추가 되어 img 수정할 필요가 없어짐.
loader.load('xx.png');

//md
const md =(v, el)=>el.innerHTML = parseMD(v);
loader.parser = (md, el('#b')); //상태가 추가 되어 md 수정할 필요가 없어짐.
loader.load('xx.md');
```

## 소유 위임에서 정의시점과 실행시점

그래서 위의 img, md 함수도 정의시점으로 올릴 수 있게 되었다.  
```
//정의 시점 시작
<script src="Github.js"></script>
<script src="img.js"></script>
<script src="md.js"></script>
//정의 시점 끝
//실행시점 선택 시작
<script>
const loader = new Github('hikaMaeng', 'codespitz75');

loader.setParser = (img, el('#a')); //상태가 추가 되어 img 수정할 필요가 없어짐.
loader.load('xx.png');

loader.parser = (md, el('#b')); //상태가 추가 되어 md 수정할 필요가 없어짐.
loader.load('xx.md');
</script>
//실행시점 선택 끝
```

## 실행시점 선택 위임

```javascript
const loader = new Github('hikaMaeng', 'codespitz75');

loader.setParser = (img, el('#a'));
loader.load('xx.png');

loader.parser = (md, el('#b'));
loader.load('xx.md');
```

라우터.

연산과 용량의 대체.

## Jsonp

* jsonp: same-origin policy 으로 인해 ajax 로 프로토콜, 포트, 호스트가 다를 경우 호출이 실패한다. 이를 회피하는게 jsonp  
방식은 아래의 코드와같이 callback 과 callback 시 호출될 함수를 미리 만들어서 지정한다.  
callback 함수로 지정된 함수는 리턴 값을 인자로 받아 실행된다.  
당연히 a 함수는 스크립트 호출 전에 존재해야 함.

```
function a(data){

}
<script src="http:/naver.com/a.js?callback=a"></script>
```
위의 네이버의 a.js의 호출 결과는 a({meta:{}, data:{contents:{}}}) 이런 식으로 실행된다.

위의 코드에서 a 함수는 전역을 오염시키므로, github 이란 전역객체를 하나 만들고  
그 안에 callback 함수를 넘버링으로 명명하면 전역을 오염시키지 않고 여러개를 마음대로 만들 수 있다.  

```javascript
const github = {}
github.callback0 = function a(data){
    delete github.callback0; //이미 썼으니 지우자.
    document.head.removeChild(s); //head가 점점 늘어날테니 지우자.
    data...
}
github.callback1 = function b(data){

}
var s = document.createElement('script');
document.head.appendChild(s);
s.src = 'http:/naver.com/a.js?callback=github.callback0';

```






