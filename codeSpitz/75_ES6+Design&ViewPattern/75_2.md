# Code Spitz 75 - 2 Day

[Code Spitz 75](https://www.facebook.com/groups/codespitz/) 강의 내용을 정리한 글 입니다.

## Design Pattern Category

GOF의 디자인패턴 분류    
 - 생성패턴 : 객체를 만드는 건 이런 식이 좋다 라는 패턴  
 - 구조패턴 : 객체간의 관계를 만들때 이런 식이 좋다 라는 패턴  
 - 행동패턴 : 알고리즘적인 문제를 객체간의 협력망으로 풀자.  

 이건 객체지향에 숙달한 사람을 지향한다.  

 객체지향설계를 학습할 수 있는 분류  
 - 다형성, 캡슐화, 객체관계, 변화율, 역할모델 => 이중에 역할모델이 가장 중요.  

 알고리즘이 변화하는 이유는? 
- 비즈니스변화, 연관 라이브러리 변화, 호스트측 변화 => 대부분 통제불가요소 => 변화를 수용할 수 밖에 없다.  

기존 제어문 기반의 알고리즘이 갖는 문제 : 수정하면 전체가 컴파일 됨.    

전체가 컴파일 되는 문제를 해결하기 위해 환경이 변화거나 수정요청이 발생 했을 때,  
유연하게 대응하는 실천 방법 => **적응형 프로그램**   
그리고 실천방법중 하나가 **객체지향프로그래밍**    

아래와 같이 다양한 케이스가 존재하는 코드가 있다고 해보자.
```javascript
if(case == 1){
    //....
}else if(case == 2){
    //....
}else if(case == 3){
    //....
}
```
위와 같은 코드의 경우 아래 코드 처럼 최대한 개별 알고리즘을 함수로 분리한다.
```javascript
if(case == 1){
    case1();
}else if(case == 2){
    case2();
}else if(case == 3){
    case3();
}
```



문제 1. 경우가 변경될 때.
문제 2. 함수 간 공통부분

알고리즘 분화(if.. case...) 시 객체지향에서 선택할 수 있는 두가지 방법
1. 상속 위임 - 내부계약관계로 추상층에서 공통요소를 해결하고 상태를 공유할 수 있음. 첫날 사용해던 방법.
2. 소유 위임 - 외부계약 관계로 각각이 독립적인 문제를 해결하며 메세지를 주고 받는 것으로 문제를 해결함. Gof DP 방향성. - 문제점:형이 많이 나온다.

개발실력이 뛰어나도 도메인에 대해 잘 모른다면, 변화에 따른 역할분리 제대로 못함.  

상속 위임 샘플코드
```javascript
const Github = class{
    constructor(id, repo){
        this._base = `http://api.github.com/repos/${id}/${repo}/contents/`;
    }
    load(path){
        const id = 'callback' + Github._id++;
        const f = Github[id] = ({data:{content}})=>{
            delete Github[id];
            document.head.removeChild(s);
            this._loaded(content);
        };
        const s = document.createElement('script');
        
    }
}
``` 

상속위임 깃헙 코드 - jsonp 찾아보기. 

jsonp: a 사이트에 b.js 를 script 로 가져올때 뒤에 callback=c 라고 보냈을 때 c 함수를 미리정의해놓으면
c 함수에 값을 넣어서 호출해준다.

상속위임 - Template Method Pattern

구상, 구현 => concrete

클래스의 자식클래스를 만듬으로 써 경우의 수를 분기했다.

동일 코드를 소유위임으로..

연산과 용량의 대체.



